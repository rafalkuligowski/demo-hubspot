"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractZipArchive = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = require("path");
const os_1 = require("os");
const extract_zip_1 = __importDefault(require("extract-zip"));
const fileSystemErrors_1 = require("../errors/fileSystemErrors");
const standardErrors_1 = require("../errors/standardErrors");
const logger_1 = require("./logging/logger");
const lang_1 = require("../utils/lang");
const i18nKey = 'lib.archive';
async function extractZip(name, zip) {
    const result = { extractDir: '', tmpDir: '' };
    const TMP_FOLDER_PREFIX = `hubspot-temp-${name}-`;
    logger_1.logger.log((0, lang_1.i18n)(`${i18nKey}.extractZip.init`));
    // Write zip to disk
    let tmpZipPath = '';
    try {
        result.tmpDir = await fs_extra_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), TMP_FOLDER_PREFIX));
        tmpZipPath = (0, path_1.join)(result.tmpDir, 'hubspot-temp.zip');
        await fs_extra_1.default.ensureFile(tmpZipPath);
        await fs_extra_1.default.writeFile(tmpZipPath, zip, {
            mode: 0o777,
        });
    }
    catch (err) {
        if (tmpZipPath || result.tmpDir) {
            (0, fileSystemErrors_1.throwFileSystemError)(err, {
                filepath: tmpZipPath || result.tmpDir,
                write: true,
            });
        }
        else {
            (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.extractZip.errors.write`, {}, err);
        }
        return result;
    }
    // Extract zip
    try {
        const tmpExtractPath = (0, path_1.join)(result.tmpDir, 'extracted');
        await (0, extract_zip_1.default)(tmpZipPath, { dir: tmpExtractPath });
        result.extractDir = tmpExtractPath;
    }
    catch (err) {
        (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.extractZip.errors.extract`, {}, err);
    }
    logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.extractZip.success`));
    return result;
}
async function copySourceToDest(src, dest, { sourceDir, includesRootDir = true } = {}) {
    try {
        logger_1.logger.log((0, lang_1.i18n)(`${i18nKey}.copySourceToDest.init`));
        const srcDirPath = [src];
        if (includesRootDir) {
            const files = await fs_extra_1.default.readdir(src);
            const rootDir = files[0];
            if (!rootDir) {
                logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.copySourceToDest.sourceEmpty`));
                // Create the dest path if it doesn't already exist
                fs_extra_1.default.ensureDir(dest);
                // No root found so nothing to copy
                return true;
            }
            srcDirPath.push(rootDir);
        }
        if (sourceDir) {
            srcDirPath.push(sourceDir);
        }
        const projectSrcDir = (0, path_1.join)(...srcDirPath);
        await fs_extra_1.default.copy(projectSrcDir, dest);
        logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.copySourceToDest.success`));
        return true;
    }
    catch (err) {
        logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.copySourceToDest.error`, { dest }));
        (0, fileSystemErrors_1.throwFileSystemError)(err, {
            filepath: dest,
            write: true,
        });
    }
    return false;
}
function cleanupTempDir(tmpDir) {
    if (!tmpDir)
        return;
    try {
        fs_extra_1.default.remove(tmpDir);
    }
    catch (e) {
        logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.cleanupTempDir.error`, { tmpDir }));
    }
}
async function extractZipArchive(zip, name, dest, { sourceDir, includesRootDir } = {}) {
    let success = false;
    if (zip) {
        const { extractDir, tmpDir } = await extractZip(name, zip);
        if (extractDir !== null) {
            success = await copySourceToDest(extractDir, dest, {
                sourceDir,
                includesRootDir,
            });
        }
        cleanupTempDir(tmpDir);
    }
    return success;
}
exports.extractZipArchive = extractZipArchive;
