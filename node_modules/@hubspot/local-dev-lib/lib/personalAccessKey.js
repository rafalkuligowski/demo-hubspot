"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateConfigWithAccessToken = exports.enabledFeaturesForPersonalAccessKey = exports.accessTokenForPersonalAccessKey = exports.getAccessToken = void 0;
const moment_1 = __importDefault(require("moment"));
const environments_1 = require("../constants/environments");
const auth_1 = require("../constants/auth");
const standardErrors_1 = require("../errors/standardErrors");
const localDevAuth_1 = require("../api/localDevAuth");
const sandboxHubs_1 = require("../api/sandboxHubs");
const config_1 = require("../config");
const config_2 = require("../constants/config");
const developerTestAccounts_1 = require("../api/developerTestAccounts");
const logger_1 = require("./logging/logger");
const apiErrors_1 = require("../errors/apiErrors");
const i18nKey = 'lib.personalAccessKey';
const refreshRequests = new Map();
function getRefreshKey(personalAccessKey, expiration) {
    return `${personalAccessKey}-${expiration || 'fresh'}`;
}
async function getAccessToken(personalAccessKey, env = environments_1.ENVIRONMENTS.PROD, accountId) {
    let response;
    try {
        response = await (0, localDevAuth_1.fetchAccessToken)(personalAccessKey, env, accountId);
    }
    catch (e) {
        const error = e;
        if (error.response) {
            (0, standardErrors_1.throwAuthErrorWithMessage)(`${i18nKey}.errors.invalidPersonalAccessKey`, { errorMessage: error.response.data.message || '' }, error);
        }
        else {
            (0, standardErrors_1.throwError)(e);
        }
    }
    return {
        portalId: response.hubId,
        accessToken: response.oauthAccessToken,
        expiresAt: (0, moment_1.default)(response.expiresAtMillis).toISOString(),
        scopeGroups: response.scopeGroups,
        enabledFeatures: response.enabledFeatures,
        encodedOAuthRefreshToken: response.encodedOAuthRefreshToken,
        hubName: response.hubName,
        accountType: response.accountType,
    };
}
exports.getAccessToken = getAccessToken;
async function refreshAccessToken(personalAccessKey, env = environments_1.ENVIRONMENTS.PROD, accountId) {
    const accessTokenResponse = await getAccessToken(personalAccessKey, env, accountId);
    const { accessToken, expiresAt } = accessTokenResponse;
    const config = (0, config_1.getAccountConfig)(accountId);
    (0, config_1.updateAccountConfig)({
        env,
        ...config,
        accountId,
        tokenInfo: {
            accessToken,
            expiresAt: expiresAt,
        },
    });
    (0, config_1.writeConfig)();
    return accessTokenResponse;
}
async function getNewAccessToken(accountId, personalAccessKey, expiresAt, env) {
    const key = getRefreshKey(personalAccessKey, expiresAt);
    if (refreshRequests.has(key)) {
        return refreshRequests.get(key);
    }
    let accessTokenResponse;
    try {
        const refreshAccessPromise = refreshAccessToken(personalAccessKey, env, accountId);
        if (key) {
            refreshRequests.set(key, refreshAccessPromise);
        }
        accessTokenResponse = await refreshAccessPromise;
    }
    catch (e) {
        if (key) {
            refreshRequests.delete(key);
        }
        throw e;
    }
    return accessTokenResponse;
}
async function accessTokenForPersonalAccessKey(accountId) {
    const account = (0, config_1.getAccountConfig)(accountId);
    if (!account) {
        (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.accountNotFound`, { accountId });
    }
    const { auth, personalAccessKey, env } = account;
    const authTokenInfo = auth && auth.tokenInfo;
    const authDataExists = authTokenInfo && auth?.tokenInfo?.accessToken;
    if (!authDataExists ||
        (0, moment_1.default)().add(5, 'minutes').isAfter((0, moment_1.default)(authTokenInfo.expiresAt))) {
        return getNewAccessToken(accountId, personalAccessKey, authTokenInfo && authTokenInfo.expiresAt, env).then(tokenInfo => tokenInfo.accessToken);
    }
    return auth?.tokenInfo?.accessToken;
}
exports.accessTokenForPersonalAccessKey = accessTokenForPersonalAccessKey;
async function enabledFeaturesForPersonalAccessKey(accountId) {
    const account = (0, config_1.getAccountConfig)(accountId);
    if (!account) {
        (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.accountNotFound`, { accountId });
    }
    const { auth, personalAccessKey, env } = account;
    const authTokenInfo = auth && auth.tokenInfo;
    const accessTokenResponse = await getNewAccessToken(accountId, personalAccessKey, authTokenInfo && authTokenInfo.expiresAt, env);
    return accessTokenResponse?.enabledFeatures;
}
exports.enabledFeaturesForPersonalAccessKey = enabledFeaturesForPersonalAccessKey;
async function updateConfigWithAccessToken(token, personalAccessKey, env, name, makeDefault = false) {
    const { portalId, accessToken, expiresAt, accountType } = token;
    const accountEnv = env || (0, config_1.getEnv)(name);
    let parentAccountId;
    try {
        if (accountType === config_2.HUBSPOT_ACCOUNT_TYPES.STANDARD_SANDBOX ||
            accountType === config_2.HUBSPOT_ACCOUNT_TYPES.DEVELOPMENT_SANDBOX) {
            const sandboxDataResponse = await (0, sandboxHubs_1.fetchSandboxHubData)(accessToken, portalId, accountEnv);
            if (sandboxDataResponse.parentHubId) {
                parentAccountId = sandboxDataResponse.parentHubId;
            }
        }
    }
    catch (err) {
        // Log error but do not throw
        logger_1.logger.debug((0, apiErrors_1.getAxiosErrorWithContext)(err).message);
    }
    try {
        if (accountType === config_2.HUBSPOT_ACCOUNT_TYPES.DEVELOPER_TEST) {
            const developerTestAccountResponse = await (0, developerTestAccounts_1.fetchDeveloperTestAccountData)(accessToken, portalId, accountEnv);
            if (developerTestAccountResponse) {
                parentAccountId = developerTestAccountResponse.parentPortalId;
            }
        }
    }
    catch (err) {
        // Log error but do not throw
        logger_1.logger.debug((0, apiErrors_1.getAxiosErrorWithContext)(err).message);
    }
    const updatedConfig = (0, config_1.updateAccountConfig)({
        accountId: portalId,
        accountType,
        personalAccessKey,
        name,
        authType: auth_1.PERSONAL_ACCESS_KEY_AUTH_METHOD.value,
        tokenInfo: { accessToken, expiresAt },
        parentAccountId,
        env: accountEnv,
    });
    (0, config_1.writeConfig)();
    if (makeDefault && name) {
        (0, config_1.updateDefaultAccount)(name);
    }
    return updatedConfig;
}
exports.updateConfigWithAccessToken = updateConfigWithAccessToken;
