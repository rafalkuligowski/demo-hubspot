"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.outputLogs = void 0;
const moment_1 = __importDefault(require("moment"));
const chalk_1 = __importDefault(require("chalk"));
const logger_1 = require("./logger");
const lang_1 = require("../../utils/lang");
const i18nKey = 'lib.logging.logs';
const SEPARATOR = ' - ';
const LOG_STATUS_COLORS = {
    SUCCESS: logger_1.Styles.success,
    ERROR: logger_1.Styles.error,
    UNHANDLED_ERROR: logger_1.Styles.error,
    HANDLED_ERROR: logger_1.Styles.error,
};
function errorHandler(log, options) {
    return `${formatLogHeader(log, options)}${formatError(log, options)}`;
}
const logHandler = {
    ERROR: errorHandler,
    UNHANDLED_ERROR: errorHandler,
    HANDLED_ERROR: errorHandler,
    SUCCESS: (log, options) => {
        return `${formatLogHeader(log, options)}${formatSuccess(log, options)}`;
    },
};
function formatSuccess(log, options) {
    if (!log.log || options.compact) {
        return '';
    }
    return `\n${log.log}`;
}
function formatError(log, options) {
    if (!log.error || options.compact) {
        return '';
    }
    return `${log.error.type}: ${log.error.message}\n${formatStackTrace(log)}`;
}
function formatLogHeader(log, options) {
    const color = LOG_STATUS_COLORS[log.status];
    const headerInsertion = options && options.insertions && options.insertions.header;
    return `${formatTimestamp(log)}${SEPARATOR}${color(log.status)}${headerInsertion ? `${SEPARATOR}${headerInsertion}` : ''}${SEPARATOR}${formatExecutionTime(log)}`;
}
function formatStackTrace(log) {
    const stackTrace = (log.error.stackTrace && log.error.stackTrace[0]) || [];
    return stackTrace
        .map(trace => {
        return `  at ${trace}\n`;
    })
        .join('');
}
function formatTimestamp(log) {
    return `${chalk_1.default.whiteBright((0, moment_1.default)(log.createdAt).toISOString())}`;
}
function formatExecutionTime(log) {
    return `${chalk_1.default.whiteBright('Execution Time:')} ${log.executionTime}ms`;
}
function processLog(log, options) {
    try {
        return logHandler[log.status](log, options);
    }
    catch (e) {
        logger_1.logger.error((0, lang_1.i18n)(`${i18nKey}.unableToProcessLog`, {
            log: JSON.stringify(log),
        }));
    }
}
function processLogs(logsResp, options) {
    if (!logsResp || (logsResp.results && !logsResp.results.length)) {
        return 'No logs found.';
    }
    else if (logsResp.results && logsResp.results.length) {
        return logsResp.results
            .map(log => {
            return processLog(log, options);
        })
            .join('\n');
    }
}
function outputLogs(logsResp, options) {
    logger_1.logger.log(processLogs(logsResp, options));
}
exports.outputLogs = outputLogs;
