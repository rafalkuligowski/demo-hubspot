"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mkcert = void 0;
const utils_js_1 = require("./utils.js");
const downloader_js_1 = require("./downloader.js");
const source_js_1 = require("./source.js");
class Mkcert {
    force;
    mkcertSavedPath;
    source;
    KEY_FILE_PATH;
    CERT_FILE_PATH;
    /**
     *
     * @param {{ force?: boolean, keyFilePath: string, certFilePath: string }} options
     */
    constructor(options) {
        const { force, keyFilePath, certFilePath } = options;
        // TODO: allow override
        this.KEY_FILE_PATH = keyFilePath;
        this.CERT_FILE_PATH = certFilePath;
        this.force = force ?? false;
        this.source = new source_js_1.GithubSource();
        this.mkcertSavedPath = (0, utils_js_1.resolvePath)(process.platform === 'win32' ? 'mkcert.exe' : 'mkcert');
    }
    async getMkcertBinary() {
        return this.checkMkcert() ? this.mkcertSavedPath : undefined;
    }
    /**
     * Check if mkcert exists
     */
    checkMkcert() {
        return (0, utils_js_1.existsSync)(this.mkcertSavedPath);
    }
    async getCertificate() {
        const key = await (0, utils_js_1.readFile)(this.KEY_FILE_PATH);
        const cert = await (0, utils_js_1.readFile)(this.CERT_FILE_PATH);
        return {
            key,
            cert,
        };
    }
    /**
     * @param {string[]} hosts
     */
    async createCertificate(hosts) {
        const names = hosts.join(' ');
        const mkcertBinary = await this.getMkcertBinary();
        await (0, utils_js_1.ensureDirExist)(this.KEY_FILE_PATH);
        await (0, utils_js_1.ensureDirExist)(this.CERT_FILE_PATH);
        const cmd = `${(0, utils_js_1.wrapInQuotes)(mkcertBinary)} -install -key-file ${(0, utils_js_1.wrapInQuotes)(this.KEY_FILE_PATH)} -cert-file ${(0, utils_js_1.wrapInQuotes)(this.CERT_FILE_PATH)} ${names}`;
        await (0, utils_js_1.exec)(cmd, {
            env: {
                ...process.env,
                JAVA_HOME: undefined,
            },
        });
    }
    getCurrentMkcertVersion = async () => {
        const mkcertBinary = await this.getMkcertBinary();
        if (!mkcertBinary) {
            return null;
        }
        const { stdout } = await (0, utils_js_1.exec)(`"${mkcertBinary}" --version`, {
            env: {
                ...process.env,
                JAVA_HOME: undefined,
            },
        });
        const version = stdout.trim();
        return version;
    };
    /**
     * @param {string[]} hosts
     */
    async regenerate(hosts) {
        await this.createCertificate(hosts);
    }
    async init() {
        if (!this.checkMkcert()) {
            await this.initMkcert();
        }
    }
    async getSourceInfo() {
        const sourceInfo = await this.source.getSourceInfo();
        if (!sourceInfo) {
            return undefined;
        }
        return sourceInfo;
    }
    async initMkcert() {
        const sourceInfo = await this.getSourceInfo();
        await this.downloadMkcert(sourceInfo.downloadUrl, this.mkcertSavedPath);
    }
    /**
     *
     * @param {string} sourceUrl
     * @param {string} distPath
     */
    async downloadMkcert(sourceUrl, distPath) {
        const downloader = new downloader_js_1.Downloader();
        await downloader.download(sourceUrl, distPath);
    }
    /**
     * @param {string[]} hosts
     */
    async renew(hosts) {
        if (this.force || !((0, utils_js_1.existsSync)(this.CERT_FILE_PATH) && (0, utils_js_1.existsSync)(this.KEY_FILE_PATH))) {
            await this.regenerate(hosts);
        }
    }
    /**
     * Get certificates
     *
     * @param {string[]} hosts host collection
     * @returns certificates
     */
    async install(hosts) {
        await this.renew(hosts);
        return await this.getCertificate();
    }
}
exports.Mkcert = Mkcert;
