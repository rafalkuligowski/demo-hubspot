"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAbsolutePath = exports.ensureDirExist = exports.writeFile = exports.wrapInQuotes = exports.resolvePath = exports.DATA_DIR = exports.exec = exports.getDefaultHosts = exports.readFile = exports.existsSync = void 0;
const os_1 = require("os");
const child_process_1 = require("child_process");
const util_1 = require("util");
const path_1 = require("path");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
var fs_2 = require("fs");
Object.defineProperty(exports, "existsSync", { enumerable: true, get: function () { return fs_2.existsSync; } });
var promises_2 = require("fs/promises");
Object.defineProperty(exports, "readFile", { enumerable: true, get: function () { return promises_2.readFile; } });
const getLocalV4Ips = () => {
    const interfaceDict = (0, os_1.networkInterfaces)();
    const addresses = [];
    for (const key in interfaceDict) {
        const interfaces = interfaceDict[key];
        if (interfaces) {
            for (const item of interfaces) {
                /** @type {*} */
                const family = item.family;
                if (family === 'IPv4' || family === 4) {
                    addresses.push(item.address);
                }
            }
        }
    }
    return addresses;
};
const getDefaultHosts = () => {
    return ['localhost', ...getLocalV4Ips()];
};
exports.getDefaultHosts = getDefaultHosts;
/**
 * @param {string} cmd
 * @param {import("child_process").ExecOptions} options
 * @returns
 */
const exec = async (cmd, options) => {
    return await (0, util_1.promisify)(child_process_1.exec)(cmd, options);
};
exports.exec = exec;
exports.DATA_DIR = (0, path_1.join)((0, os_1.homedir)(), '.mkcert-cli');
/**
 * @param {string} path
 * @param {string=} baseDir
 * @returns {string}
 */
const resolvePath = (path, baseDir = exports.DATA_DIR) => {
    return (0, path_1.resolve)(baseDir, path);
};
exports.resolvePath = resolvePath;
/**
 * @param {string=} path
 * @returns {`"${string}"`}
 */
const wrapInQuotes = (path) => {
    return `"${path}"`;
};
exports.wrapInQuotes = wrapInQuotes;
/**
 * @param {string} filePath
 * @param {string | Uint8Array} data
 */
const writeFile = async (filePath, data) => {
    if (!(0, fs_1.existsSync)(filePath)) {
        await (0, promises_1.mkdir)((0, path_1.dirname)(filePath), { recursive: true });
    }
    await (0, promises_1.writeFile)(filePath, data);
    await (0, promises_1.chmod)(filePath, 0o777);
};
exports.writeFile = writeFile;
/**
 * @param {string} filePath
 */
const ensureDirExist = async (filePath) => {
    if (!(0, fs_1.existsSync)((0, path_1.dirname)(filePath))) {
        await (0, promises_1.mkdir)((0, path_1.dirname)(filePath));
    }
};
exports.ensureDirExist = ensureDirExist;
/**
 * Get absolute path from import.meta.url and relative descriptor
 * @param {string} relative
 * @param {string} filePath
 * @returns {string}
 */
const getAbsolutePath = (relative, filePath) => {
    return new URL(relative, filePath).pathname;
};
exports.getAbsolutePath = getAbsolutePath;
