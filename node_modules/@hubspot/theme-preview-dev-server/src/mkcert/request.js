"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.request = void 0;
const https_1 = __importDefault(require("https"));
const defaultHeaders = {
    Accept: 'application/json, text/plain, */*',
    ['User-Agent']: `mkcert-cli/`,
};
const MAX_REDIRECTS = 4;
// https://github.com/axios/axios/blob/main/lib/adapters/http.js#L335
/**
 * @param {string} url
 * @param {Record<string, string>} customHeaders
 * @param {'json' | 'arrayBuffer'} responseType
 * @returns {Promise<any>}
 */
const request = async (url, customHeaders = {}, responseType = 'json', _redirect = 0) => {
    const headers = { ...defaultHeaders, ...customHeaders };
    return new Promise((resolve) => {
        /** @type {Uint8Array[]} */
        const responseBuffer = [];
        https_1.default.get(url, { headers }, async (res) => {
            const { headers: resHeaders, statusCode, statusMessage } = res;
            // Handle redirects (very naively)
            if (statusCode && resHeaders.location && 300 <= statusCode && statusCode <= 399) {
                if (_redirect > MAX_REDIRECTS) {
                    throw new Error(`Too many redirects (${MAX_REDIRECTS}). Final url: ${url}`);
                }
                const response = await (0, exports.request)(resHeaders.location, customHeaders, responseType, _redirect++);
                resolve(response);
            }
            res.on('data', (chunk) => {
                responseBuffer.push(chunk);
                if (url.includes('/download/')) {
                }
            });
            res.on('end', () => {
                const arrayBuffer = Buffer.concat(responseBuffer);
                switch (responseType) {
                    case 'json': {
                        return resolve(JSON.parse(arrayBuffer.toString()));
                    }
                    case 'arrayBuffer': {
                        return resolve(arrayBuffer);
                    }
                }
            });
        });
    });
};
exports.request = request;
