"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHttpsRedirectingServer = void 0;
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const net_1 = __importDefault(require("net"));
const os_1 = __importDefault(require("os"));
const fs_1 = require("fs");
const mkcert_1 = require("./mkcert");
const tmpkey = `${os_1.default.tmpdir()}/hstmp/hsLocalSshKey.pem`;
const tmpcert = `${os_1.default.tmpdir()}/hstmp/hsLocalSshCert.pem`;
const createCert = async (domainsToProxy) => {
    const additionalMkcertHosts = domainsToProxy
        .map((proxyDomain) => [
        `${proxyDomain.domain}.localhost`,
        `${proxyDomain.domain}.hslocal.net`
    ])
        .flat();
    const hosts = ['localhost', 'hslocal.net', ...additionalMkcertHosts];
    const { key, cert } = await (0, mkcert_1.createCertificate)({
        keyFilePath: tmpkey,
        certFilePath: tmpcert
    }, hosts);
    (0, fs_1.unlinkSync)(tmpkey);
    (0, fs_1.unlinkSync)(tmpcert);
    return { key, cert };
};
const requireHTTPS = (message, response) => {
    const newLocation = `https://${message.headers.host}${message.url}`;
    response
        .writeHead(302, {
        Location: newLocation,
    })
        .end();
};
// Running http and https servers on the same port pulled from https://stackoverflow.com/a/42019773
const createHttpsRedirectingServer = async (handler, domainsToProxy) => {
    const { key, cert } = await createCert(domainsToProxy);
    const innerHTTPServer = http_1.default.createServer(requireHTTPS);
    const innerHTTPSServer = https_1.default.createServer({ key, cert }, handler);
    const server = net_1.default.createServer(socket => {
        socket.once('data', buffer => {
            // Pause the socket
            socket.pause();
            // Determine if this is an HTTP(s) request
            const byte = buffer[0];
            let protocol;
            if (byte === 22) {
                protocol = 'https';
            }
            else if (32 < byte && byte < 127) {
                protocol = 'http';
            }
            else {
                throw new Error('Unknown issue with incoming data, unknown if http or https');
            }
            const proxy = protocol === 'http' ? innerHTTPServer : innerHTTPSServer;
            if (proxy) {
                // Push the buffer back onto the front of the data stream
                socket.unshift(buffer);
                // Emit the socket to the HTTP(s) server
                proxy.emit('connection', socket);
            }
            // As of NodeJS 10.x the socket must be
            // resumed asynchronously or the socket
            // connection hangs, potentially crashing
            // the process. Prior to NodeJS 10.x
            // the socket may be resumed synchronously.
            process.nextTick(() => socket.resume());
        });
    });
    return { server, innerHTTPServer, innerHTTPSServer };
};
exports.createHttpsRedirectingServer = createHttpsRedirectingServer;
