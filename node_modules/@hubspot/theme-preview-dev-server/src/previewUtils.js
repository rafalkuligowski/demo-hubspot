"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildHTMLResponse = exports.isUngatedForPreview = exports.trackPreviewEvent = exports.hidePreviewInDest = exports.memoize = exports.isInternalCMSRoute = exports.getSubDomainFromValidLocalDomain = exports.addRefreshScript = exports.getPreviewUrl = exports.isModuleFolderChild = exports.getPortalDomains = exports.VALID_PROXY_DOMAIN_SUFFIXES = void 0;
const path_1 = __importDefault(require("path"));
const domains_js_1 = require("./api/domains.js");
const config_1 = require("@hubspot/local-dev-lib/config");
const os_1 = require("os");
const querystring_1 = require("querystring");
const logger_1 = require("@hubspot/local-dev-lib/logger");
const trackUsage_1 = require("@hubspot/local-dev-lib/trackUsage");
const personalAccessKey_1 = require("@hubspot/local-dev-lib/personalAccessKey");
const path_2 = require("@hubspot/local-dev-lib/path");
const extensions_1 = require("@hubspot/local-dev-lib/constants/extensions");
exports.VALID_PROXY_DOMAIN_SUFFIXES = ['localhost', 'hslocal.net'];
const HS_PREVIEW_GATE = "cms:localHublPreviews";
const getPortalDomains = async (accountId) => {
    try {
        const result = await (0, domains_js_1.fetchDomains)(accountId);
        return result.results;
    }
    catch (error) {
        return [];
    }
};
exports.getPortalDomains = getPortalDomains;
const isModuleFolderChild = (filePath) => {
    const pathParts = (0, path_2.splitLocalPath)(filePath);
    if (pathParts.length <= 1)
        return false;
    return pathParts
        .slice(0, pathParts.length - 1)
        .some(part => (0, path_2.getExt)(path_1.default.normalize(part)) === extensions_1.MODULE_EXTENSION);
};
exports.isModuleFolderChild = isModuleFolderChild;
const getPreviewUrl = (sessionInfo, queryParams) => {
    const { accountId, env, hublet } = sessionInfo;
    return `http://${accountId}.hubspotpreview${env === 'qa' ? 'qa' : ''}-${hublet}.com/_hcms/preview/template/multi?${(0, querystring_1.stringify)(queryParams)}`;
};
exports.getPreviewUrl = getPreviewUrl;
const insertAtEndOfBody = (html, script) => {
    const insertAt = (baseStr, index, insertStr) => {
        return `${baseStr.slice(0, index)}${insertStr}${baseStr.slice(index)}`;
    };
    const endOfBodyIndex = html.lastIndexOf("</body>");
    return insertAt(html, endOfBodyIndex, script);
};
const addRefreshScript = (html) => {
    const refreshScript = `
  <script>
  (() => {
    const MAX_WAIT = 16000;
    const NORMAL_WAIT_MS = 1000;
    const BACKOFF_RATIO = 2;
    let nextWait = NORMAL_WAIT_MS;
    let timeWaited = 0;

    setInterval(() => {
      timeWaited += NORMAL_WAIT_MS;
      if (timeWaited !== nextWait) return;
      timeWaited = 0;
      const res = fetch(window.location.origin + '/meta')
        .then(async (res) => {
          const hsServerState = await res.json();
          if (hsServerState["REMOTE_FS_IS_DIRTY"]) {
            location.reload();
          }
          nextWait = NORMAL_WAIT_MS;
        })
        .catch(err => {
          if (nextWait * BACKOFF_RATIO <= MAX_WAIT) {
            nextWait *= BACKOFF_RATIO;
          }
          console.log('Disconnected from local server... (retrying in ' + nextWait / 1000 + 's)');
        });
    }, NORMAL_WAIT_MS);
  })();
  </script>
  `;
    return insertAtEndOfBody(html, refreshScript);
};
exports.addRefreshScript = addRefreshScript;
const getSubDomainFromValidLocalDomain = (hostname) => {
    for (const validProxyDomainSuffix of exports.VALID_PROXY_DOMAIN_SUFFIXES) {
        if (hostname.endsWith(`.${validProxyDomainSuffix}`)) {
            return hostname.slice(0, -1 * validProxyDomainSuffix.length - 1);
        }
    }
};
exports.getSubDomainFromValidLocalDomain = getSubDomainFromValidLocalDomain;
const internalRoutes = {
    HCMS: '/_hcms/',
    HS_FS: '/hs-fs/',
    HUB_FS: '/hubfs/'
};
const isInternalCMSRoute = (req) => Object.values(internalRoutes).some((route => req.path.startsWith(route)));
exports.isInternalCMSRoute = isInternalCMSRoute;
const memoize = (func, cacheBustCallback) => {
    const cache = {};
    return async (...args) => {
        const stringArgs = args.toString();
        const storedResult = cache[stringArgs];
        if (storedResult && (cacheBustCallback ? !cacheBustCallback() : true)) {
            //console.log(`Cache hit ${func}`)
            return storedResult;
        }
        //console.log(`Cache miss ${func}`)
        const res = await func(...args);
        cache[stringArgs] = res;
        return res;
    };
};
exports.memoize = memoize;
const hidePreviewInDest = (previewDest) => previewDest.split('/').slice(2).join('/');
exports.hidePreviewInDest = hidePreviewInDest;
const trackPreviewEvent = async (action) => {
    if (!(0, config_1.isTrackingAllowed)()) {
        return;
    }
    const accountId = (0, config_1.getAccountId)();
    (0, trackUsage_1.trackUsage)('cli-interaction', 'INTERACTION', {
        applicationName: 'hubspot.preview',
        os: `${(0, os_1.platform)()} ${(0, os_1.release)()}`,
        authType: getAuthType(accountId),
        action,
    }, accountId ? accountId : undefined).catch((err) => {
        logger_1.logger.debug(`trackUsage failed: ${JSON.stringify(err, null, 2)}`);
    });
};
exports.trackPreviewEvent = trackPreviewEvent;
const isUngatedForPreview = async (sessionInfo) => {
    const { accountId } = sessionInfo;
    const enabledFeatures = await (0, personalAccessKey_1.enabledFeaturesForPersonalAccessKey)(accountId);
    return (Object.keys(enabledFeatures).includes(HS_PREVIEW_GATE)
        && enabledFeatures[HS_PREVIEW_GATE]);
};
exports.isUngatedForPreview = isUngatedForPreview;
const buildHTMLResponse = (content) => {
    return `
    <!DOCTYPE html>
      <head>
      </head>
      <body>
        ${content}
      </body>
  `;
};
exports.buildHTMLResponse = buildHTMLResponse;
const getAuthType = (accountId) => {
    let authType = 'unknown';
    if (accountId) {
        const accountConfig = (0, config_1.getAccountConfig)(accountId);
        if (accountConfig && accountConfig.authType) {
            authType = accountConfig.authType;
        }
    }
    return authType;
};
