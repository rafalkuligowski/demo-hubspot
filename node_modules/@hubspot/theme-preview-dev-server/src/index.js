"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.preview = void 0;
const http_1 = __importDefault(require("http"));
const path_1 = __importDefault(require("path"));
const chokidar_1 = __importDefault(require("chokidar"));
const express_1 = __importDefault(require("express"));
const session_1 = require("./api/session");
const fileMapper_1 = require("@hubspot/local-dev-lib/api/fileMapper");
const config_1 = require("@hubspot/local-dev-lib/config");
const createRoutes_js_1 = require("./createRoutes.js");
const previewUtils_js_1 = require("./previewUtils.js");
const meta_js_1 = require("./routes/meta.js");
const sprocketMenuServer_js_1 = require("./sprocketMenuServer.js");
const httpsRedirectingServer_js_1 = require("./httpsRedirectingServer.js");
const logger_1 = require("@hubspot/local-dev-lib/logger");
const path_2 = require("@hubspot/local-dev-lib/path");
const ignoreRules_1 = require("@hubspot/local-dev-lib/ignoreRules");
const uploadFolder_1 = require("@hubspot/local-dev-lib/cms/uploadFolder");
const escapeRegExp_1 = require("@hubspot/local-dev-lib/escapeRegExp");
const notify_1 = require("@hubspot/local-dev-lib/notify");
async function uploadFile(accountId, src, dest) {
    logger_1.logger.debug(`Attempting to upload file "${src}" to "${dest}"`);
    try {
        await (0, fileMapper_1.upload)(accountId, src, dest);
        logger_1.logger.log(`Uploaded file ${src} to ${dest}`);
        (0, meta_js_1.markRemoteFsDirty)();
    }
    catch {
        const uploadFailureMessage = `Uploading file ${src} to ${dest} failed`;
        logger_1.logger.debug(uploadFailureMessage);
        logger_1.logger.debug(`Retrying to upload file "${src}" to "${dest}"`);
        try {
            await (0, fileMapper_1.upload)(accountId, src, dest);
            (0, meta_js_1.markRemoteFsDirty)();
        }
        catch (error) {
            logger_1.logger.error(uploadFailureMessage);
        }
    }
}
async function deleteRemoteFile(accountId, remoteFilePath) {
    logger_1.logger.debug(`Attempting to delete file "${remoteFilePath}"`);
    try {
        await (0, fileMapper_1.deleteFile)(accountId, remoteFilePath);
        logger_1.logger.log(`Deleted file ${remoteFilePath}`);
        (0, meta_js_1.markRemoteFsDirty)();
    }
    catch (error) {
        logger_1.logger.error(`Deleting file ${remoteFilePath} failed`);
        logger_1.logger.debug(`Retrying deletion of file ${remoteFilePath}`);
        try {
            await (0, fileMapper_1.deleteFile)(accountId, remoteFilePath);
            (0, meta_js_1.markRemoteFsDirty)();
        }
        catch (err) {
            logger_1.logger.error(`Deleting file ${remoteFilePath} failed`);
        }
    }
}
const getDesignManagerPath = (src, dest, file) => {
    const regex = new RegExp(`^${(0, escapeRegExp_1.escapeRegExp)(src)}`);
    const relativePath = file.replace(regex, '');
    return (0, path_2.convertToUnixPath)(path_1.default.join(dest, relativePath));
};
const buildDeleteFileFromPreviewBufferCallback = (sessionInfo, type) => {
    const { accountId, src, dest, notify } = sessionInfo;
    return (filePath) => {
        if ((0, ignoreRules_1.shouldIgnoreFile)(filePath)) {
            logger_1.logger.debug(`Skipping ${filePath} due to an ignore rule`);
            return;
        }
        if (type === 'file') {
            const moduleChild = (0, previewUtils_js_1.isModuleFolderChild)(filePath);
            const filename = path_1.default.basename(filePath);
            if (moduleChild && filename === 'meta.json') {
                return;
            }
        }
        const remotePath = getDesignManagerPath(src, dest, filePath);
        const deletePromise = deleteRemoteFile(accountId, remotePath);
        (0, notify_1.triggerNotify)(notify, 'Removed', filePath, deletePromise);
    };
};
const buildUploadFileToPreviewBufferCallback = (sessionInfo, notifyMessage) => {
    const { accountId, src, dest, notify } = sessionInfo;
    return async (filePath) => {
        if (!(0, path_2.isAllowedExtension)(filePath)) {
            logger_1.logger.debug(`Skipping ${filePath} due to unsupported extension`);
            return;
        }
        if ((0, ignoreRules_1.shouldIgnoreFile)(filePath)) {
            logger_1.logger.debug(`Skipping ${filePath} due to an ignore rule`);
            return;
        }
        if (path_1.default.dirname(filePath) === src &&
            ["theme.json", "fields.json"].includes(path_1.default.basename(filePath))) {
            logger_1.logger.warn(`Editing of theme fields or meta is not yet supported.`);
            return;
        }
        const destPath = getDesignManagerPath(src, dest, filePath);
        const uploadPromise = uploadFile(accountId, filePath, destPath);
        (0, notify_1.triggerNotify)(notify, notifyMessage, filePath, uploadPromise);
    };
};
const initialPreviewBufferUpload = async (sessionInfo, filePaths, uploadOptions) => {
    const { accountId, src, dest } = sessionInfo;
    const { onFinishCallback, ...rest } = uploadOptions;
    const results = await (0, uploadFolder_1.uploadFolder)(accountId, src, dest, {}, rest, filePaths);
    onFinishCallback(results);
};
const startPreviewWatcher = async (sessionInfo) => {
    const { src } = sessionInfo;
    let watcherIsReady = false;
    const watcher = chokidar_1.default.watch(src, {
        ignoreInitial: true, // makes initial addition of files not trigger the watcher
        ignored: file => (0, ignoreRules_1.shouldIgnoreFile)(file),
    });
    const addFileCallback = buildUploadFileToPreviewBufferCallback(sessionInfo, 'Added');
    const changeFileCallback = buildUploadFileToPreviewBufferCallback(sessionInfo, 'Change');
    const deleteFileCallback = buildDeleteFileFromPreviewBufferCallback(sessionInfo, 'file');
    const deleteFolderCallback = buildDeleteFileFromPreviewBufferCallback(sessionInfo, 'folder');
    watcher.on('ready', () => {
        watcherIsReady = true;
    });
    watcher.on('add', addFileCallback);
    watcher.on('change', changeFileCallback);
    watcher.on('error', error => logger_1.logger.error(`An error occurred while watching files: ${error}`));
    watcher.on('unlink', deleteFileCallback);
    watcher.on('unlinkDir', deleteFolderCallback);
    function sleep(ms) {
        return new Promise(resolve => {
            setTimeout(resolve, ms);
        });
    }
    while (!watcherIsReady) {
        await sleep(1);
        // do nothing... surely there's a better way to do this...
    }
    return watcher;
};
const createLocalHttpServer = async (sessionInfo) => {
    const expressServer = (0, express_1.default)();
    expressServer.use('/', await (0, createRoutes_js_1.createPreviewServerRoutes)(sessionInfo));
    return expressServer;
};
const preview = async (accountId, src, dest, { notify, filePaths, skipUpload, noSsl, port, uploadOptions, handleUserInput }) => {
    (0, logger_1.setLogLevel)(logger_1.LOG_LEVEL.LOG);
    const accountConfig = (0, config_1.getAccountConfig)(accountId);
    if (!accountConfig) {
        logger_1.logger.error(`Failed to get account config for ${accountId}`);
        return;
    }
    const domains = await (0, previewUtils_js_1.getPortalDomains)(accountId);
    let sessionToken;
    try {
        const res = await (0, session_1.initiateSession)(accountId);
        sessionToken = res.token;
    }
    catch (err) {
        logger_1.logger.error(`Failed to initiate session: ${err}`);
        return;
    }
    const PORT = port || 3000;
    const protocol = noSsl ? 'http' : 'https';
    const sessionInfo = {
        src,
        dest: `@preview/${sessionToken}/${dest}`,
        fakeDest: dest,
        portalName: accountConfig.name,
        accountId,
        env: accountConfig.env,
        personalAccessKey: accountConfig.personalAccessKey,
        // we find hublet later in the content metadata fetch
        // can we get that ahead of time? hardcoding it for now
        hublet: 'na1',
        sessionToken,
        domains,
        PORT,
        protocol,
    };
    const ungated = await (0, previewUtils_js_1.isUngatedForPreview)(sessionInfo);
    if (!ungated) {
        logger_1.logger.log(`\nPortal ${accountId} is missing a required gate for this feature.`);
        process.exit();
    }
    if (notify) {
        (0, ignoreRules_1.ignoreFile)(notify);
    }
    if (!skipUpload) {
        await initialPreviewBufferUpload(sessionInfo, filePaths, uploadOptions);
    }
    const expressServer = await createLocalHttpServer(sessionInfo);
    const previewWatcher = await startPreviewWatcher(sessionInfo);
    if (!noSsl) {
        const { server, innerHTTPServer, innerHTTPSServer, } = await (0, httpsRedirectingServer_js_1.createHttpsRedirectingServer)(expressServer, domains);
        server.listen(PORT);
    }
    else {
        const httpServer = http_1.default.createServer(expressServer);
        httpServer.listen(PORT);
    }
    (0, sprocketMenuServer_js_1.startSprocketMenuServer)(sessionInfo);
    logger_1.logger.log(`\nLocal dev server started at ${protocol}://hslocal.net:${PORT} for account ${accountId}`);
    if (handleUserInput) {
        handleUserInput();
        logger_1.logger.log(`Press 'q' to quit\n`);
    }
};
exports.preview = preview;
