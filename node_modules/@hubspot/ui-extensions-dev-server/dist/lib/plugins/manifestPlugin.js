"use strict";
/* hs-eslint ignored failing-rules */
/* eslint-disable hubspot-dev/no-unsupported-ts-syntax */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const constants_1 = require("../constants");
const path_2 = __importDefault(require("path"));
// @ts-expect-error no type defs for the logger
const logger_1 = require("@hubspot/cli-lib/logger");
const utils_1 = require("../utils");
const PACKAGE_LOCK_FILE = 'package-lock.json';
const PACKAGE_FILE = 'package.json';
const EXTENSIONS_PATH = 'src/app/extensions/';
const manifestPlugin = (options) => {
    return {
        name: 'ui-extensions-manifest-generation-plugin',
        enforce: 'post',
        generateBundle(_rollupOptions, bundle) {
            const { output, minify = false, extensionPath = process.cwd() } = options;
            try {
                const filename = path_2.default.parse(output).name;
                const manifest = _generateManifestContents(bundle, extensionPath);
                this.emitFile({
                    type: 'asset',
                    source: minify
                        ? JSON.stringify(manifest)
                        : JSON.stringify(manifest, null, 2),
                    fileName: (0, path_1.normalize)(`${filename}-${constants_1.MANIFEST_FILE}`),
                });
            }
            catch (e) {
                logger_1.logger.warn(`\nUnable to write manifest file in ${output}, ${e}`);
            }
        },
    };
};
function _generateManifestContents(bundle, extensionPath) {
    const baseManifest = {
        package: _loadPackageFile(extensionPath),
    };
    // The keys to bundle are the filename without any path information
    const bundles = Object.keys(bundle).filter((cur) => cur.endsWith('.js'));
    if (bundles.length === 1) {
        return Object.assign(Object.assign({}, _generateManifestEntry(bundle[bundles[0]])), baseManifest);
    }
    const manifest = bundles.reduce((acc, current) => {
        return Object.assign(Object.assign({}, acc), { [current]: _generateManifestEntry(bundle[current]) });
    }, {});
    return Object.assign(Object.assign({}, manifest), baseManifest);
}
function _generateManifestEntry(subBundle) {
    const { facadeModuleId, moduleIds, modules } = subBundle;
    return {
        entry: _stripPathPriorToExtDir(facadeModuleId),
        modules: _buildModulesInfo(moduleIds, modules),
    };
}
function _loadJsonFileSafely(extensionPath, filename) {
    try {
        return JSON.parse((0, fs_1.readFileSync)(path_2.default.join(extensionPath, filename)).toString());
    }
    catch (e) {
        return undefined;
    }
}
function _loadPackageFile(extensionPath) {
    // Look for package-lock.json then fallback to package.json
    return (_loadJsonFileSafely(extensionPath, PACKAGE_LOCK_FILE) ||
        _loadJsonFileSafely(extensionPath, PACKAGE_FILE));
}
function _stripPathPriorToExtDir(filepath) {
    return filepath === null || filepath === void 0 ? void 0 : filepath.split(EXTENSIONS_PATH).pop();
}
function _buildModulesInfo(moduleIds, modules) {
    const accumulator = {
        internal: [],
        external: [],
    };
    return moduleIds.reduce((acc, mod) => {
        const { renderedExports } = modules[mod];
        const moduleData = {
            module: _stripPathPriorToExtDir(mod),
            renderedExports,
        };
        if ((0, utils_1.isNodeModule)(moduleData.module)) {
            acc.external.push(moduleData);
        }
        else {
            acc.internal.push(moduleData);
        }
        return acc;
    }, accumulator);
}
exports.default = manifestPlugin;
