"use strict";
/* eslint-disable hubspot-dev/no-unsupported-ts-syntax */
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseAbstractSyntaxTree = void 0;
// @ts-expect-error no type defs
const estraverse_1 = require("estraverse");
function _isVariableImported(node, variableName) {
    if (!node) {
        return false;
    }
    return ((node.type === 'ImportSpecifier' && node.imported.name === variableName) ||
        (node.type === 'ImportDefaultSpecifier' &&
            node.local.name === variableName) ||
        (node.type === 'ImportNamespaceSpecifier' &&
            node.local.name === variableName));
}
function _isIdentifierDefined(node, parent, name) {
    if (parent &&
        (parent.type === 'MemberExpression' || parent.type === 'CallExpression')) {
        return false;
    }
    return node.type === 'Identifier' && node.name === name;
}
function _isFunctionInvoked(node, functionName) {
    return (node.type === 'CallExpression' &&
        node.callee &&
        'name' in node.callee &&
        node.callee.name === functionName);
}
function _checkForFunctionMetadata(node, parent, output, functionName) {
    if (!node) {
        return;
    }
    if (!output.functions[functionName]) {
        output.functions[functionName] = {};
    }
    if (_isFunctionInvoked(node, functionName)) {
        output.functions[functionName].invoked = true;
        // If the function is invoked before being defined we will assume it is a global function
        output.functions[functionName].scope = output.functions[functionName]
            .defined
            ? 'Local'
            : 'Global';
    }
    else if (_isIdentifierDefined(node, parent, functionName) ||
        _isVariableImported(node, functionName)) {
        output.functions[functionName].defined = true;
    }
}
// Traverses an ESTree as defined by the EsTree spec https://github.com/estree/estree
// Uses the checks array to search the source code for matches
function traverseAbstractSyntaxTree(ast, checks) {
    const state = {
        functions: {},
    };
    (0, estraverse_1.traverse)(ast, {
        enter(node, parent) {
            checks.forEach((check) => {
                _checkForFunctionMetadata(node, parent, state, check.functionName);
            });
        },
    });
    return state;
}
exports.traverseAbstractSyntaxTree = traverseAbstractSyntaxTree;
