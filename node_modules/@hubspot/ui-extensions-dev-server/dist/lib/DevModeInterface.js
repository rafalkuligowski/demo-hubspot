"use strict";
/* hs-eslint ignored failing-rules */
/* eslint-disable hubspot-dev/no-unsupported-ts-syntax */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dev_1 = require("./dev");
const constants_1 = require("./constants");
const constants_2 = require("./constants");
const config_1 = require("./config");
const DevServerState_1 = require("./DevServerState");
const utils_1 = require("./utils");
const defaultLogger = {
    info: (...args) => {
        console.log(...args);
    },
    debug: (...args) => {
        console.log(...args);
    },
    warn: (...args) => {
        console.error(...args);
    },
    error: (...args) => {
        console.error(...args);
    },
};
class DevModeInterface {
    constructor() {
        this.logger = defaultLogger;
    }
    _generateAppExtensionMappings(components) {
        // Loop over all of the app configs that are passed in
        const allComponentNames = Object.keys(components);
        return allComponentNames.reduce((appExtensionMappings, componentName) => {
            var _a, _b;
            const component = components[componentName];
            if (!((_b = (_a = component.config.extensions) === null || _a === void 0 ? void 0 : _a.crm) === null || _b === void 0 ? void 0 : _b.cards)) {
                return appExtensionMappings; // It's not an app
            }
            // Load all of the extension configs for a particular app.json file
            const extensionsConfigForApp = (0, config_1.loadExtensionConfig)(component.config, component.path);
            const extensionConfigKeys = Object.keys(extensionsConfigForApp);
            // Loop over the loaded extension configs and generate the list of choices to use to prompt the user for input
            extensionConfigKeys.forEach((extensionKey) => {
                const extensionConfig = extensionsConfigForApp[extensionKey];
                appExtensionMappings.push({
                    name: `${componentName}/${extensionConfig.data.title}`,
                    value: extensionConfig,
                });
            });
            return appExtensionMappings;
        }, []);
    }
    _getPlatformVersion(projectConfig) {
        const { platformVersion } = projectConfig !== null && projectConfig !== void 0 ? projectConfig : {};
        if (!platformVersion) {
            return constants_2.PLATFORM_VERSION.V20231;
        }
        switch (platformVersion) {
            case constants_2.PLATFORM_VERSION.V20231:
                return constants_2.PLATFORM_VERSION.V20231;
            case constants_2.PLATFORM_VERSION.V20232:
                return constants_2.PLATFORM_VERSION.V20232;
            default:
                return (0, utils_1.throwUnhandledPlatformVersionError)(platformVersion);
        }
    }
    setup({ components, extensionConfig, onUploadRequired, promptUser, logger, urls, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger = logger;
            this.onUploadRequired = onUploadRequired;
            this.urls = urls;
            if (extensionConfig) {
                this.configs = [extensionConfig];
                return;
            }
            const choices = this._generateAppExtensionMappings(components);
            if (choices.length === 0) {
                throw new Error('No extensions to run');
            }
            else if (choices.length === 1) {
                this.configs = [choices[0].value];
            }
            else {
                const answers = yield promptUser({
                    type: 'checkbox',
                    name: 'extensions',
                    message: 'Which extension(s) would you like to run?',
                    validate: (input) => {
                        if (!input || input.length === 0) {
                            return 'Select at least one extension to run';
                        }
                        const appNames = new Set(input.map((choice) => choice.data.appName));
                        if (appNames.size > 1) {
                            return 'Running multiple extensions is only supported for a single application';
                        }
                        return true;
                    },
                    choices,
                });
                this.configs = answers.extensions;
            }
        });
    }
    // The contract is for this to be async, so eslint can chill
    // eslint-disable-next-line require-await
    fileChange(filePath, __event) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.devServerState || !this.devServerState.extensionsMetadata) {
                return;
            }
            const relevantConfigFileChanged = this.devServerState.extensionsMetadata.some((metadata) => metadata.config.extensionConfigPath === filePath);
            if (relevantConfigFileChanged && this.onUploadRequired) {
                this.onUploadRequired();
            }
        });
    }
    start({ requestPorts, accountId, projectConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            let expressPort = constants_1.EXPRESS_DEFAULT_PORT;
            let webSocketPort = constants_1.WEBSOCKET_DEFAULT_PORT;
            if (requestPorts) {
                try {
                    const portData = yield requestPorts([
                        { instanceId: constants_1.EXPRESS_SERVER_ID, port: constants_1.EXPRESS_DEFAULT_PORT },
                        { instanceId: constants_1.VITE_DEV_SERVER_ID, port: constants_1.WEBSOCKET_DEFAULT_PORT },
                    ]);
                    expressPort = portData[constants_1.EXPRESS_SERVER_ID];
                    webSocketPort = portData[constants_1.VITE_DEV_SERVER_ID];
                }
                catch (e) {
                    this.logger.debug('Call to port manager failed, using default ports');
                }
            }
            this.devServerState = new DevServerState_1.DevServerState({
                extensionConfigs: this.configs,
                accountId,
                platformVersion: this._getPlatformVersion(projectConfig),
                expressPort,
                webSocketPort,
                logger: this.logger,
                urls: this.urls,
            });
            this.shutdown = yield (0, dev_1.startDevMode)(this.devServerState);
            this.devServerState.extensionsMetadata.forEach((metadata) => {
                const { config: { data: { title, appName }, }, } = metadata;
                this.logger.info(`Running extension '${title}' from app '${appName}'`);
            });
        });
    }
    cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.shutdown) {
                yield this.shutdown();
            }
        });
    }
}
exports.default = new DevModeInterface();
