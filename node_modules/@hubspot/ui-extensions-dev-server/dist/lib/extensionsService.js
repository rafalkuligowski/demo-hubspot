"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable hubspot-dev/no-unsupported-ts-syntax */
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const utils_1 = require("./utils");
class ExtensionsService {
    constructor() {
        this.endpoint = '/extensions';
    }
    add(server, devServerState, capabilities) {
        server.get(this.endpoint, this.generateExtensionsHandler(devServerState, capabilities));
        return [this.endpoint];
    }
    generateExtensionsHandler(devServerState, capabilities = []) {
        return function extensionsHandler(_req, res) {
            try {
                const extensions = devServerState.extensionsMetadata.map((metadata) => {
                    const { baseMessage } = metadata;
                    const output = path_1.default.parse(baseMessage.callback).name;
                    return Object.assign(Object.assign({}, baseMessage), { manifest: (0, utils_1.loadManifest)(devServerState.outputDir, output) });
                });
                const response = {
                    websocket: `ws://localhost:${devServerState.webSocketPort}`,
                    version: constants_1.EXTENSIONS_MESSAGE_VERSION,
                    capabilities,
                    portalId: devServerState.portalId,
                    extensions,
                };
                res.status(200).json(response);
            }
            catch (e) {
                res.status(500).json({
                    message: 'Unable to determine which extensions are running',
                });
            }
        };
    }
}
exports.default = new ExtensionsService();
