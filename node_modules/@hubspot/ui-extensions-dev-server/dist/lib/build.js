"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.remoteBuild = exports.buildSingleExtension = exports.extensionErrorBaseMessage = void 0;
const vite_1 = require("vite");
const constants_1 = require("./constants");
const manifestPlugin_1 = __importDefault(require("./plugins/manifestPlugin"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("./utils");
const codeBlockingPlugin_1 = __importDefault(require("./plugins/codeBlockingPlugin"));
const friendlyLoggingPlugin_1 = __importDefault(require("./plugins/friendlyLoggingPlugin"));
const allowedExtensions = ['.js', '.ts', '.tsx', '.jsx'];
exports.extensionErrorBaseMessage = `Supported file extensions are [${allowedExtensions.join(', ')}], received:`;
function buildSingleExtension({ file, outputDir = constants_1.OUTPUT_DIR, emptyOutDir = true, minify = false, root = process.cwd(), // This is the vite default, so using that as our default
 }) {
    return __awaiter(this, void 0, void 0, function* () {
        const output = (0, utils_1.getUrlSafeFileName)(file);
        yield (0, vite_1.build)({
            root,
            define: {
                'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'production'),
            },
            build: {
                lib: {
                    entry: file,
                    name: output,
                    formats: ['iife'],
                    fileName: () => output,
                },
                rollupOptions: Object.assign(Object.assign({}, constants_1.ROLLUP_OPTIONS), { plugins: [
                        (0, manifestPlugin_1.default)({ output, extensionPath: root }),
                        (0, friendlyLoggingPlugin_1.default)({ logger: console }),
                        (0, codeBlockingPlugin_1.default)({ logger: console }),
                    ] }),
                outDir: outputDir,
                emptyOutDir,
                minify,
            },
        });
    });
}
exports.buildSingleExtension = buildSingleExtension;
function remoteBuild(root, entryPoint, outputDir = constants_1.OUTPUT_DIR) {
    return __awaiter(this, void 0, void 0, function* () {
        const fileInfo = path_1.default.parse(entryPoint);
        if (!allowedExtensions.includes(fileInfo.ext)) {
            throw new Error(`${exports.extensionErrorBaseMessage} ${fileInfo.ext}`);
        }
        yield buildSingleExtension({
            file: entryPoint,
            outputDir,
            minify: true,
            root,
        });
    });
}
exports.remoteBuild = remoteBuild;
