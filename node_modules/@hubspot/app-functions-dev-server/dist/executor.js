"use strict";
/* hs-eslint ignored failing-rules */
/* eslint-disable hubspot-dev/no-unsupported-ts-syntax */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeFunction = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const config_1 = require("./config");
const secrets_1 = require("./secrets");
const context_1 = require("./context");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
function executeFunction(config, functionName, localExecutionInputs, callback) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { logger } = config;
        const { appId } = localExecutionInputs;
        const functionInfo = (0, config_1.loadFunctionInfo)(config, functionName, appId);
        const functionPath = path_1.default.resolve(path_1.default.join(functionInfo.srcDir, functionInfo.file));
        if (!fs_1.default.existsSync(functionPath)) {
            logger.error(`Could not find file ${functionPath}.`);
            throw new errors_1.ExecutionError({
                reason: errors_1.Reason.FunctionNotFound,
                functionName,
                appId,
            });
        }
        delete require.cache[require.resolve(functionPath)];
        const { main } = yield require(functionPath);
        if (!main) {
            logger.error(`Could not find "main" export in ${functionPath}.`);
            throw new errors_1.ExecutionError({
                reason: errors_1.Reason.InvalidFunction,
                functionName,
            });
        }
        const savedEnv = Object.assign({}, process.env);
        const secrets = (0, secrets_1.loadSecrets)(functionInfo.srcDir);
        const { deleted: missingSecrets } = (0, utils_1.diffLists)(
        // secrets expected
        (_a = functionInfo.secrets) !== null && _a !== void 0 ? _a : [], 
        // secrets available
        Object.keys(process.env));
        if (missingSecrets.length > 0) {
            logger.warn(`The following required secrets are missing: ${missingSecrets}. Please supply them as environment variables for local execution in a .env file.`);
        }
        let context;
        try {
            context = yield (0, context_1.buildContext)(config, localExecutionInputs, secrets);
        }
        catch (err) {
            process.env = savedEnv;
            throw err;
        }
        // eslint-disable-next-line no-async-promise-executor, consistent-return
        const rawResponse = yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            // Start the timer to throw an error after 20s unless the timer
            // is unref'd after the function completes (even with error)
            const ms = config.functionTimeoutMs;
            const timeout = setTimeout(() => {
                process.env = savedEnv;
                logger.error(`App function failed to callback within ${(0, utils_1.formatSeconds)(ms, 2)}.`);
                reject(new errors_1.ExecutionError({
                    reason: errors_1.Reason.Timeout,
                    functionName,
                    elapsedTimeMs: ms,
                }));
            }, ms);
            // Catch any error thrown from the function, which may or may not be async
            try {
                switch (config.platformVersion) {
                    case constants_1.PLATFORM_VERSION.V20231:
                        yield main(context, (response) => {
                            clearTimeout(timeout);
                            process.env = savedEnv;
                            resolve(response);
                        });
                        break;
                    case constants_1.PLATFORM_VERSION.V20232: {
                        const response = yield main(context);
                        clearTimeout(timeout);
                        process.env = savedEnv;
                        resolve(response);
                        break;
                    }
                    default:
                        return (0, utils_1.throwUnhandledPlatformVersionError)(config.platformVersion);
                }
            }
            catch (error) {
                clearTimeout(timeout);
                process.env = savedEnv;
                logger.error(`App function encountered an uncaught error.`, error);
                reject(new errors_1.ExecutionError({
                    reason: errors_1.Reason.UncaughtError,
                    functionName,
                    cause: error,
                }));
            }
            finally {
                timeout.unref();
            }
        }));
        // Confirm that the response is valid JSON
        let jsonResponse = null;
        try {
            jsonResponse =
                rawResponse === undefined
                    ? null
                    : JSON.parse(JSON.stringify(rawResponse));
        }
        catch (error) {
            logger.error(`App function reponse is not valid JSON.`);
            throw new errors_1.ExecutionError({
                reason: errors_1.Reason.InvalidResponse,
                functionName,
            });
        }
        callback(jsonResponse);
    });
}
exports.executeFunction = executeFunction;
//# sourceMappingURL=executor.js.map